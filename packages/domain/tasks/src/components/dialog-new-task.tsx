import type { ZonedDateTime } from "@internationalized/date";

import type {
	task_priorityType as TaskPriority,
	task_statusType as TaskStatus,
} from "@shared/electric-sql";

import { useEffect, useRef } from "react";

import { faPlus } from "@fortawesome/pro-solid-svg-icons/faPlus";
import { zodResolver } from "@hookform/resolvers/zod";
import { fromDate, getLocalTimeZone } from "@internationalized/date";
import {
	Button,
	ComboBox,
	DateInput,
	DatePicker,
	Dialog,
	Form,
	Grid,
	Group,
	Icon,
	Input,
	KeyboardShortcutIndicator,
	Label,
	Switch,
	TextArea,
} from "boondoggle";
import { genUUID } from "electric-sql/util";
import { useFormContext } from "react-hook-form";
import { useDispatch, useSelector } from "react-redux";
import { z } from "zod";

import { TasksSchema, useElectric } from "@shared/electric-sql";
import * as i18n from "@shared/i18n";

import { useLaunchDialog } from "../lib/keyboard-shortcuts";
import { PRIORITY_MENU_ITEMS } from "../lib/priority-menu-items";
import {
	createAnotherUpdated,
	createTaskDialogOpenChange,
	defaultPriorityUpdated,
	defaultStatusUpdated,
	selectIsCreateTaskDialogOpen,
	selectTasksCreateAnother,
	selectTasksDefaultPriority,
	selectTasksDefaultStatus,
} from "../redux/create-tasks-slice";
import { IconTaskStatus } from "./icon-task-status";

import "../css/index.css";

/**
 * The schema used when validating the for for creating a new task.
 * This is a subset of the `Tasks` schema that is generated by Electric SQL.
 *
 * Note: There's some weirdness with the description and due_date fields that
 * are optional in the DB schema, but are being inferred as `nullish` rather
 * than `optional` by Electric SQL. These have just been overridden for speed,
 * but it's worth investigating why this is happening in the future.
 */
const createTaskSchema = TasksSchema.omit({
	created_at: true,
	description: true,
	due_date: true,
	id: true,
	updated_at: true,
}).merge(
	z.object({
		// There's a bug in Electric SQL / Prisma where the `description` field
		// is inferred as `nullish` rather than `optional`. This is a workaround for now.
		description: z.string().optional(),
		// The `DatePicker` component returns a `ZonedDateTime` object
		// which we can convert to a `Date` when writing to the db.
		due_date: z
			.custom<ZonedDateTime>()
			.optional()
			.transform((v) => {
				if (v) {
					return v.toDate();
				}
			}),
	}),
);
type CreateTask = z.infer<typeof createTaskSchema>;

/**
 * The fields for the "new task" dialog. These are intentionally abstracted from
 * the dialog itself, as they "create another task" functionality requires access to the
 * `FormContext` provided by react-hook-form to detect form submission, reset the form, and
 * focus the title input.
 */
function NewTaskFields({ close }: { close: () => void }) {
	const {
		formState: { isSubmitSuccessful },
		reset,
	} = useFormContext();
	const dispatch = useDispatch();

	// Allow keeping the dialog open after a task has been created
	// so that the user can create another task without having to
	// re-open the dialog.
	const create_another = useSelector(selectTasksCreateAnother);
	const default_status = useSelector(selectTasksDefaultStatus);
	const default_priority = useSelector(selectTasksDefaultPriority);
	const title_input_ref = useRef<HTMLInputElement>(null);

	// It is recommended in the React Hook Form documentation to use `useEffect` to
	// handle side effects like resetting the form after a successful submission.
	useEffect(() => {
		if (isSubmitSuccessful) {
			reset({
				description: "",
				priority: default_priority,
				status: default_status,
				title: "",
			});
			if (create_another) {
				title_input_ref.current?.focus();
			} else {
				close();
			}
		}
	}, [close, create_another, default_priority, default_status, isSubmitSuccessful, reset]);

	return (
		<>
			<Form.TextField autoFocus className="mb-4" name="title">
				<Label>{i18n.title}</Label>
				<Input ref={title_input_ref} />
			</Form.TextField>

			<Form.TextField className="mb-4" name="description">
				<Label>{i18n.description}</Label>
				<TextArea />
			</Form.TextField>

			<Form.DatePicker
				className="mb-4"
				data-testid="due_date"
				granularity="minute"
				name="due_date"
			>
				<Label>{i18n.due_date}</Label>
				<Group>
					<DateInput unstyled />
					<DatePicker.ClearButton />
					<DatePicker.Button />
				</Group>
				<Grid className="mt-2" columns={3}>
					<DatePicker.Preset
						date={fromDate(new Date(), getLocalTimeZone()).set({
							hour: 18,
							millisecond: 0,
							minute: 0,
							second: 0,
						})}
					>
						{i18n.date_preset_today}
					</DatePicker.Preset>
					<DatePicker.Preset
						date={fromDate(new Date(), getLocalTimeZone()).add({ days: 1 }).set({
							hour: 18,
							millisecond: 0,
							minute: 0,
							second: 0,
						})}
					>
						{i18n.date_preset_tomorrow}
					</DatePicker.Preset>
					<DatePicker.Preset
						date={fromDate(new Date(), getLocalTimeZone()).add({ weeks: 1 }).set({
							hour: 18,
							millisecond: 0,
							minute: 0,
							second: 0,
						})}
					>
						{i18n.date_preset_1_week}
					</DatePicker.Preset>
				</Grid>
			</Form.DatePicker>

			<hr />

			<Form.ComboBox<TaskPriority>
				className="mb-4"
				defaultItems={PRIORITY_MENU_ITEMS}
				name="priority"
				onSelectionChange={(p) => {
					dispatch(
						defaultPriorityUpdated(
							// quirk of react-aria-components combobox
							// means we lose type info on the key — meaning to open a PR
							p?.toString() as TaskPriority,
						),
					);
				}}
			>
				<Label>{i18n.priority}</Label>
				<Group>
					<ComboBox.Input unstyled />
					<ComboBox.Button />
				</Group>
			</Form.ComboBox>

			<Form.ComboBox<TaskStatus>
				className="mb-4"
				defaultItems={[
					{
						id: "to_do",
						name: i18n.status_to_do,
						slotLeft: <IconTaskStatus status="to_do" />,
					},
					{
						id: "in_progress",
						name: i18n.status_in_progress,
						slotLeft: <IconTaskStatus status="in_progress" />,
					},
					{
						id: "completed",
						name: i18n.status_completed,
						slotLeft: <IconTaskStatus status="completed" />,
					},
				]}
				name="status"
				onSelectionChange={(p) => {
					dispatch(
						defaultStatusUpdated(
							// quirk of react-aria-components combobox
							// means we lose type info on the key — meaning to open a PR
							p?.toString() as TaskStatus,
						),
					);
				}}
			>
				<Label>{i18n.status}</Label>
				<Group>
					<ComboBox.Input unstyled />
					<ComboBox.Button />
				</Group>
			</Form.ComboBox>
		</>
	);
}

export function DialogNewTask() {
	// We create a task directly from the component with electric-sql
	// as mutations aren't really suited to be handled by Redux.
	const { db } = useElectric() || {};
	if (!db) {
		throw new Error("Electric client not found");
	}

	const addTask = async (p: CreateTask) => {
		const date = new Date(Date.now());
		await db.tasks.create({
			data: {
				...p,
				created_at: date,
				id: genUUID(),
				updated_at: date,
			},
		});
	};

	// Allow keeping the dialog open after a task has been created
	// so that the user can create another task without having to
	// re-open the dialog.
	const dispatch = useDispatch();
	const create_another = useSelector(selectTasksCreateAnother);

	// Default values for the task creation form.
	const default_status = useSelector(selectTasksDefaultStatus);
	const default_priority = useSelector(selectTasksDefaultPriority);

	// Control the state of the dialog and allow launching via keyboard shortcut.
	useLaunchDialog();
	const is_open = useSelector(selectIsCreateTaskDialogOpen);

	return (
		<Dialog.Trigger
			isOpen={is_open}
			onOpenChange={(b) => {
				return dispatch(createTaskDialogOpenChange(b));
			}}
		>
			<Button appearance="secondary">
				<Icon icon={faPlus} />
				{i18n.new_task}
				<KeyboardShortcutIndicator>C</KeyboardShortcutIndicator>
			</Button>
			<Dialog.ModalOverlay isDismissable>
				<Dialog.Modal>
					<Form.Root<CreateTask>
						onError={(e) => {
							console.error(e);
						}}
						onSubmit={addTask}
						options={{
							defaultValues: {
								priority: default_priority,
								status: default_status,
							},
							resetOptions: {
								keepDefaultValues: false,
								keepDirty: false,
								keepDirtyValues: false,
								keepTouched: false,
								keepValues: false,
							},
							resolver: zodResolver(createTaskSchema),
						}}
					>
						<Dialog.Root>
							{({ close }) => {
								return (
									<>
										<Dialog.Header>
											<Dialog.Title>{i18n.new_task}</Dialog.Title>
											<Dialog.CloseButton />
										</Dialog.Header>

										<Dialog.Content>
											<NewTaskFields close={close} />
										</Dialog.Content>

										<Dialog.Footer>
											<Switch.Root
												isSelected={create_another}
												onChange={(b) => {
													return dispatch(createAnotherUpdated(b));
												}}
											>
												<Switch.Label>{i18n.create_another}</Switch.Label>
												<Switch.Indicator />
											</Switch.Root>
											<Button type="submit">{i18n.submit}</Button>
										</Dialog.Footer>
									</>
								);
							}}
						</Dialog.Root>
					</Form.Root>
				</Dialog.Modal>
			</Dialog.ModalOverlay>
		</Dialog.Trigger>
	);
}
